pipeline {
  agent { label "ec2-jnlp-slave" }
  options {
    disableConcurrentBuilds()
    quietPeriod(0)
    ansiColor('xterm')
  }
  parameters {
    string(
      name: 'VERSION',
      defaultValue: '',
      description: 'The version to deploy.  Versions are published by development pipelines and indicate which artifacts to deploy and what git tag to pull.  This should be a tag of format (number).(number).(number)  ex. 0.1.20',
      trim: false
    )
  }
  stages {
    stage("Prep Agent") {
      steps {
        script {
          currentBuild.displayName = env.VERSION

          def jenkinsUtils = load ".jenkins/groovy/JenkinsUtils.groovy"

          jenkinsUtils.installAwsCli()
          jenkinsUtils.installEcsCli()
          jenkinsUtils.installTerraform("0.12.24")

          env.DEPLOY_DATA = jenkinsUtils.pathHasChanges("data") || jenkinsUtils.pathHasChanges(".jenkins")
          env.DEPLOY_FRONTEND = jenkinsUtils.pathHasChanges("frontend") || env.DEPLOY_DATA
        }
      }
    }
    stage("Scan Images") {
      when {
        expression { env.SKIP_SCANS != "true" }
      }
      steps {
        script {
          def jenkinsUtils = load ".jenkins/groovy/JenkinsUtils.groovy"
          jenkinsUtils.triggerEcrScan("postgres_deployer", env.VERSION)
          jenkinsUtils.triggerEcrScan("django", env.VERSION)
          jenkinsUtils.triggerEcrScan("react", env.VERSION)
          jenkinsUtils.fetchEcrScanResult("postgres_deployer", env.VERSION)
          jenkinsUtils.fetchEcrScanResult("django", env.VERSION)
          jenkinsUtils.fetchEcrScanResult("react", env.VERSION)
        }
      }
      post {
        always {
          script {
            archiveArtifacts allowEmptyArchive: true, artifacts: 'ecr_scan_*.json'
          }
        }
      }
    }
    stage("Deploy Data Layer") {
      when {
        expression { env.DEPLOY_DATA == "true" || env.FORCE_DEPLOY == "true" }
      }
      steps {
        script {
          def jenkinsUtils = load ".jenkins/groovy/JenkinsUtils.groovy"
          dir('data/aws') {
            jenkinsUtils.terraformApply(env.APPLICATION_BUCKET, env.JOB_BASE_NAME, "apply",
              [
                "application_version": env.VERSION,
                "vpc_name": env.VPC_NAME
              ]
            )
          }
        }
      }
      post {
        always {
          script {
            archiveArtifacts allowEmptyArchive: true, artifacts: 'data/aws/log*'
          }
        }
      }
    }
    stage("Deploy Frontend Layer") {
      when {
        expression { env.DEPLOY_FRONTEND == "true" || env.FORCE_DEPLOY == "true" }
      }
      steps {
        script {
          def jenkinsUtils = load ".jenkins/groovy/JenkinsUtils.groovy"
          dir('frontend/aws') {
            jenkinsUtils.terraformApply(env.APPLICATION_BUCKET, env.JOB_BASE_NAME, "apply",
              [
                "application_version": env.VERSION,
                "vpc_name": env.VPC_NAME
              ]
            )
          }
        }
      }
      post {
        always {
          script {
            archiveArtifacts allowEmptyArchive: true, artifacts: 'frontend/aws/log*'
          }
        }
      }
    }
    stage("Test") {
      when {
        expression { env.SKIP_TESTS != "true" }
      }
      steps {
        script {
          def jenkinsUtils = load ".jenkins/groovy/JenkinsUtils.groovy"
          dir('frontend/aws') {
            env.APPLICATION_ENDPOINT = jenkinsUtils.terraformOutput(env.APPLICATION_BUCKET, env.JOB_BASE_NAME, "application_endpoint")
          }
          dir('tests') {
            sh '''
              set -e
              docker run --rm -e APPLICATION_ENDPOINT=$APPLICATION_ENDPOINT -v $(pwd)/testcafe:/tests testcafe/testcafe chromium /tests/**/*.js
            '''
          }
        }
      }
    }
    stage("Run Inspec Scans") {
      when {
        expression { env.SKIP_SCANS != "true" }
      }
      steps {
        script {
          def jenkinsUtils = load ".jenkins/groovy/JenkinsUtils.groovy"
          lock('docker_socket') {
            jenkinsUtils.buildAndPushImageToEcr("saf/postgres_rds", "inspec_postgres_rds", [env.BUILD_TAG, env.JOB_BASE_NAME])
          }
          dir('saf/aws') {
            jenkinsUtils.terraformApply(env.APPLICATION_BUCKET, env.JOB_BASE_NAME, "apply",
              [
                "application_version": env.BUILD_TAG,
                "vpc_name": env.VPC_NAME
              ]
            )
            jenkinsUtils.runInspecScan(
              "postgres_rds",
              jenkinsUtils.terraformOutput(env.APPLICATION_BUCKET, env.JOB_BASE_NAME, "inspec_postgres_rds_task_definition_arn"),
              jenkinsUtils.terraformOutput(env.APPLICATION_BUCKET, env.JOB_BASE_NAME, "inspec_postgres_rds_cluster"),
              jenkinsUtils.terraformOutput(env.APPLICATION_BUCKET, env.JOB_BASE_NAME, "inspec_postgres_rds_subnets"),
              jenkinsUtils.terraformOutput(env.APPLICATION_BUCKET, env.JOB_BASE_NAME, "inspec_postgres_rds_security_group")
            )
          }
        }
      }
      post {
        always {
          script {
            archiveArtifacts allowEmptyArchive: true, artifacts: 'saf/aws/inspec_scan_result_*'
          }
        }
      }
    }
  }
  post {
    success {
      script {
        withCredentials([usernameColonPassword(credentialsId: 'GIT_CREDENTIAL', variable: 'GIT_CREDENTIAL')]) {
          sh '''
            set -e
            remote_url=`git config remote.origin.url | sed -e 's|^https://||'`
            git config user.name 'Jenkins'
            git config user.email 'jenkins@mycompany.com'
            git tag $JOB_BASE_NAME -f
            git push https://$GIT_CREDENTIAL@$remote_url refs/tags/$JOB_BASE_NAME -f
          '''
          if (env.DOWNSTREAM_JOB) {
            try {
              build job: "${DOWNSTREAM_JOB}",
                parameters: [
                  string(name: 'VERSION', value: "${VERSION}")
                ],
                wait: false
            } catch (err) {
                echo err.getMessage()
            }
          }
          if (env.SAF_SCAN == "true") {
            try {
              build job: "saf",
                parameters: [
                  string(name: 'ENVIRONMENT', value: "${JOB_BASE_NAME}"),
                  string(name: 'VERSION', value: "${VERSION}"),
                  string(name: 'VPC_NAME', value: "${VPC_NAME}")
                ],
                wait: false
            } catch (err) {
              echo err.getMessage()
            }
          }
        }
      }
    }
  }
}
